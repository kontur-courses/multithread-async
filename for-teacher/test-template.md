Тест по https://rsdn.org/article/dotnet/CSThreading1.xml#E6B

Тест на 2025: https://forms.gle/fWuMLseguYdtJJHW8

**Какой тип многозадачности используется в Windows?** (один из)
* Вытесняющая
* Кооперативная

**Планирование ресурсов CPU в Windows происходит на уровне** (один из)
* Процессов
* Потоков

**Отметь все верные утверждения про поток, у которого свойство IsBackground == true** (несколько)
1. Препятствует завершению приложения после завершения главного потока
2. Не препятствует завершению приложения после завершения главного потока
3. Повышенный приоритет при планировании
4. Пониженный приоритет при планировании
5. Свойство IsBackground не влияет на приоритет при планировании

**Допустим, есть программа, в которой 1/4 (по времени выполнения) вычислений не параллелится, а 3/4 может быть эффективно распараллелено на любое количество процессоров. На 1 процессоре программа выполняется 10 секунд. Сколько секунд, минимум, будет работать программа на 3 процессорах?** (один из)
* 2,5
* 3,33333….
* 5
* 10

**Возможно ли состояние гонки (race condition) на одноядерной машине?** (один из)
* Нет
* Да
* Что такое состояние гонки? о_О

**Отметь примитивы, которые могут быть использованы для синхронизации взаимодействия двух разных процессов в Windows** (несколько)
1. lock
2. Monitor
3. Mutex
4. Semaphore
5. AutoResetEvent
6. ManualResetEvent
7. EventWaitHandle

**Есть ли разница между Semaphore с ёмкостью 1 и Mutex (кроме скорости работы)?** (один из)
* Да
* Нет

**Нужно ли добавить lock(и) в этот код? (не жульте, решайте в уме!)**
https://gist.github.com/kostteg/c2fca23c30b9b9818acfd9280d3877b6
* Нет, т.к. только один поток пишет и только один поток читает
* Да. Вызов “lock (dict)” в любом месте сделает словарь потокобезопасным для его использования после этого вызова
* Да. Нужно обрамить запись (стр. 7) в lock. Этого будет достаточно, т.к. только в этом месте изменяется состояние словаря
* Да. Нужно и чтение (стр. 17), и запись (стр. 7) делать под lock’ом